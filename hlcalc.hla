program Calculator;
#include("stdlib.hhf");

type Op: enum {
    OP_NULL,
    OP_PUT,
    OP_ADD,
    OP_SUBTRACT,
    OP_MULTIPLY,
    OP_DIVIDE,
    OP_POWER
};

static
    acc: int32 := 0;
    ans: int32 := 0;
    neg_flag: boolean := false;
    emp_flag: boolean := true;
    _op: Op := OP_PUT;
    
procedure warn(content: string);
begin warn;
	stdout.put("! ", content, nl);
end warn;

procedure answer;
begin answer;
	stdout.put("= ", ans, nl);
end answer;

procedure prompt;
begin prompt;
	stdout.put("> ");
end prompt;

procedure CollectDigit;
begin CollectDigit;
	mov(acc, ebx);
	
	sub(48, al);
    intmul(10, ebx);
    movsx(al, eax);
    add(eax, ebx);

    mov(ebx, acc);
    mov(false, emp_flag);
end CollectDigit;

procedure OpPut;
begin OpPut;
    mov(acc, ans);
end OpPut;

procedure OpAdd;
begin OpAdd;
    mov(acc, eax);
    add(eax, ans);
end OpAdd;

procedure OpSubtract;
begin OpSubtract;
    mov(acc, eax);
    sub(eax, ans);
end OpSubtract;

procedure OpMultiply;
begin OpMultiply;
	mov(acc, eax);
	mov(ans, ebx);
	imul(ebx);
	try
		into();
		mov(eax, ans);
	exception (ex.IntoInstr)		
		// Show non-persistent answer
		stdout.put("= ");
		stdout.puti64(edx:eax);
		stdout.newln();
		
		warn("Answer out of range. Calculations chain broken.");
		mov(0, ans);
	endtry;
end OpMultiply;

procedure OpDivide;
begin OpDivide;
	if (ans == 0) then stdout.put("!! /0", nl);
    else
        mov(ans, eax);
        cdq();
        idiv(acc, edx:eax);
        mov(eax, ans);
    endif;
end OpDivide;

procedure OpPower;
begin OpPower;
	mov(ans, eax);

    while (acc > 1) do
        mul(ans);
        dec(acc);
    endwhile;
    
    mov(eax, ans);
end OpPower;

procedure Operate;
begin Operate;	
	if (neg_flag) then 
		neg(acc);
	endif;
	
    if (_op == OP_PUT && !emp_flag) then
        OpPut();
        mov(OP_NULL, _op);
    elseif (_op == OP_ADD) then
        OpAdd();
        mov(OP_NULL, _op);
    elseif (_op == OP_SUBTRACT) then
        OpSubtract();
        mov(OP_NULL, _op);
    elseif (_op == OP_MULTIPLY) then
        OpMultiply();
        mov(OP_NULL, _op);
    elseif (_op == OP_DIVIDE) then
        OpDivide();
        mov(OP_NULL, _op);
    elseif (_op == OP_POWER) then
        OpPower();
        mov(OP_NULL, _op);
    endif;

    // Clear accumulator
    mov(0, acc);
	mov(true, emp_flag);
	mov(false, neg_flag);
end Operate;

begin Calculator;
   	prompt();

    forever
        stdin.getc();
        if (al >= '0' && al <= '9') then
            CollectDigit();
        elseif (al == 'q') then
            exit Calculator;
        elseif (al == '+') then
        	Operate();
            mov(OP_ADD, _op);
        elseif (al == '-' && emp_flag && _op != OP_PUT) then
        	mov(true, neg_flag);
        elseif (al == '-') then
        	Operate();
            mov(OP_SUBTRACT, _op);
        elseif (al == '*') then
        	Operate();
            mov(OP_MULTIPLY, _op);
        elseif (al == '/') then
        	Operate();
            mov(OP_DIVIDE, _op);
        elseif (al == '^') then
        	Operate();
            mov(OP_POWER, _op);
        elseif (stdin.eoln()) then
    		Operate();
    		mov(OP_PUT, _op);
   			answer();
   			prompt();
        endif;
    endfor;
end Calculator;